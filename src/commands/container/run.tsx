import { ReactNode } from "react";
import { Args, Flags } from "@oclif/core";
import { ExecRenderBaseCommand } from "../../lib/basecommands/ExecRenderBaseCommand.js";
import {
  makeProcessRenderer,
  processFlags,
} from "../../rendering/process/process_flags.js";
import { projectFlags } from "../../lib/resources/project/flags.js";
import dockerNames from "docker-names";
import { assertStatus, MittwaldAPIV2 } from "@mittwald/api-client";
import {
  getImageMeta,
  getPortMappings,
  parseEnvironmentVariables,
} from "../../lib/resources/container/containerconfig.js";
import { Success } from "../../rendering/react/components/Success.js";
import { Value } from "../../rendering/react/components/Value.js";
import ContainerUsageHints from "../../rendering/react/components/Container/ContainerUsageHints.js";

type ContainerStackResponse =
  MittwaldAPIV2.Components.Schemas.ContainerStackResponse;
type ContainerServiceResponse =
  MittwaldAPIV2.Components.Schemas.ContainerServiceResponse;
type ContainerServiceDeclareRequest =
  MittwaldAPIV2.Components.Schemas.ContainerServiceDeclareRequest;
type ContainerVolumeDeclareRequest =
  MittwaldAPIV2.Components.Schemas.ContainerVolumeDeclareRequest;
type ContainerContainerImageConfig =
  MittwaldAPIV2.Components.Schemas.ContainerContainerImageConfig;

type Result = {
  service: ContainerServiceResponse;
};

export class Run extends ExecRenderBaseCommand<typeof Run, Result> {
  static summary = "Creates and starts a new container.";
  static strict = false;

  // Usage needs to be overwritten because the autogenerated one is incorrect due to the variadic arguments.
  static usage =
    "container run [--token <value>] [-q] [-p <value>] [-e <value>...] [--env-file <value>...] [--description <value>] [--entrypoint <value>] [--name <value>] [-p <value>...] [-P] [-v <value>...] IMAGE [COMMAND] [ARGS...]";

  static flags = {
    ...processFlags,
    ...projectFlags,
    env: Flags.string({
      summary: "set environment variables in the container",
      description:
        "Format: KEY=VALUE. Multiple environment variables can be specified with multiple --env flags.",
      required: false,
      multiple: true,
      multipleNonGreedy: true,
      char: "e",
    }),
    "env-file": Flags.string({
      summary: "read environment variables from a file",
      description:
        "The file should contain lines in the format KEY=VALUE. Multiple files can be specified with multiple --env-file flags.",
      multiple: true,
      multipleNonGreedy: true,
      required: false,
    }),
    description: Flags.string({
      summary: "add a descriptive label to the container",
      description: "This helps identify the container's purpose or contents.",
      required: false,
    }),
    entrypoint: Flags.string({
      summary: "override the default entrypoint of the container image",
      description:
        "The entrypoint is the command that will be executed when the container starts. If omitted, the entrypoint defined in the image will be used.",
      required: false,
    }),
    name: Flags.string({
      summary: "assign a custom name to the container",
      description:
        "This makes it easier to reference the container in subsequent commands. If omitted, a random name will be generated automatically.",
      required: false,
    }),
    publish: Flags.string({
      summary: "publish a container's port(s)",
      description:
        "Expose a container's port within the cluster. " +
        "Format: <cluster-port>:<container-port> or just <port> (in which case the same port is used for both cluster and container). " +
        "For example, --publish 8080:80 maps port 80 in the container to port 8080 within the cluster, while --publish 8080 exposes port 8080 as port 8080. " +
        "Use multiple --publish flags to publish multiple ports.\n\n" +
        "NOTE: Please note that the usual shorthand -p is not supported for this flag, as it would conflict with the --project flag.",
      required: false,
      multiple: true,
      multipleNonGreedy: true,
    }),
    "publish-all": Flags.boolean({
      summary: "publish all ports that are defined in the image",
      description:
        "Automatically publish all ports that are exposed by the container image to random ports on the host.",
      required: false,
      char: "P",
    }),
    volume: Flags.string({
      summary: "bind mount a volume to the container",
      description:
        "This flag can be used to add volume mounts to the container. It can be used multiple times to mount multiple volumes." +
        "" +
        "Needs to be in the format <host-path>:<container-path>. " +
        "" +
        "If you specify a file path as volume, this will mount a path from your hosting environment's file system (NOT your local file system) into the container. " +
        "You can also specify a named volume, which needs to be created beforehand.",
      required: false,
      char: "v",
      multiple: true,
      multipleNonGreedy: true,
    }),
    "create-volumes": Flags.boolean({
      summary: "automatically create named volumes that do not exist",
      description:
        "When enabled, any named volumes referenced in --volume flags that do not already exist will be automatically created before starting the container.",
      required: false,
      default: false,
    }),
  };
  static args = {
    image: Args.string({
      summary: "container image to run",
      description:
        "Can be specified as a repository/tag or repository@digest (e.g., 'ubuntu:20.04' or 'alpine@sha256:abc123...'). If no tag is provided, 'latest' is assumed.",
      required: true,
    }),
    command: Args.string({
      summary: "command to run in the container",
      description:
        "This overrides the default command specified in the container image. If omitted, the default command from the image will be used. For example, 'bash' or 'python app.py'.",
      required: false,
    }),
    args: Args.string({
      summary: "arguments to pass to the command",
      description:
        "These are the runtime arguments passed to the command specified by the command parameter or the container's default command, not to the container itself. For example, if the command is 'echo', the args might be 'hello world'.",
      required: false,
    }),
  };

  protected async exec(): Promise<Result> {
    const p = makeProcessRenderer(this.flags, "Creating a container");

    const projectId = await this.withProjectId(Run);
    const stackId = projectId;
    const serviceName = this.getServiceName();

    const { image, meta: imageMeta } = await p.runStep(
      "getting image metadata",
      this.getImageAndMeta(projectId),
    );

    const serviceRequest = await p.runStep(
      "preparing service request",
      this.buildServiceRequest(image, imageMeta, serviceName),
    );

    const stack = await p.runStep(
      "creating container",
      this.addServiceToStack(stackId, serviceName, serviceRequest),
    );

    const service = stack.services?.find(matchServiceByName(serviceName));
    if (!service) {
      throw new Error("Service ID not found in the created stack.");
    }

    await p.complete(
      <Success>
        Container <Value>{service.serviceName}</Value> was successfully created
        and started.
      </Success>,
    );

    return { service };
  }

  private async addServiceToStack(
    stackId: string,
    serviceName: string,
    serviceRequest: ContainerServiceDeclareRequest,
  ): Promise<ContainerStackResponse> {
    const updateData: {
      services: { [key: string]: ContainerServiceDeclareRequest };
      volumes?: { [key: string]: ContainerVolumeDeclareRequest };
    } = {
      services: {
        [serviceName]: serviceRequest,
      },
    };

    // If create-volumes flag is enabled, add missing volumes to the same call
    if (this.flags["create-volumes"] && this.flags.volume) {
      const volumesToCreate = await this.getVolumesToCreate(stackId);
      if (volumesToCreate.length > 0) {
        updateData.volumes = Object.fromEntries(
          volumesToCreate.map((name) => [name, { name }]),
        );
      }
    }

    const resp = await this.apiClient.container.updateStack({
      stackId,
      data: updateData,
    });

    assertStatus(resp, 200);
    return resp.data;
  }

  /**
   * Gets the list of named volumes that need to be created.
   *
   * @param stackId The stack ID to check existing volumes against
   * @returns Array of volume names that need to be created
   */
  private async getVolumesToCreate(stackId: string): Promise<string[]> {
    if (!this.flags.volume) {
      return [];
    }

    // Get current stack state to check existing volumes
    const currentStackResp = await this.apiClient.container.getStack({
      stackId,
    });
    assertStatus(currentStackResp, 200);
    const existingVolumes = (currentStackResp.data.volumes || []).map(
      (v) => v.name,
    );

    // Parse volume flags to extract named volumes (not file paths)
    const namedVolumes = new Set(
      this.flags.volume
        .filter((volume) => {
          const [source] = volume.split(":");
          // Named volumes typically don't start with /
          return source && !source.startsWith("/");
        })
        .map((volume) => volume.split(":")[0]),
    );

    // Find volumes that need to be created
    return Array.from(namedVolumes).filter(
      (volumeName: string) => !existingVolumes.includes(volumeName),
    );
  }

  /**
   * Builds and returns the container command based on the provided image
   * metadata and arguments.
   *
   * @param imageMeta The configuration object containing the metadata of the
   *   container image, including the default command.
   * @returns An array of strings representing the container command to execute,
   *   or undefined if no specific command is set.
   */
  private buildContainerCommand(
    imageMeta: ContainerContainerImageConfig,
  ): string[] | undefined {
    if (!this.args.command) {
      return imageMeta.command;
    }

    const firstArg = (this.argv.lastIndexOf(this.args.command) ?? Infinity) + 1;
    const command = [this.args.command, ...this.argv.slice(firstArg)];

    return command;
  }

  /**
   * Builds a container service request from command line arguments and image
   * metadata
   *
   * @param image The container image to use
   * @param imageMeta Metadata about the container image
   * @param serviceName Name of the service to create
   * @returns A properly formatted container service request
   */
  private async buildServiceRequest(
    image: string,
    imageMeta: ContainerContainerImageConfig,
    serviceName: string,
  ): Promise<ContainerServiceDeclareRequest> {
    const command = this.buildContainerCommand(imageMeta);
    const entrypoint = this.flags.entrypoint
      ? [this.flags.entrypoint]
      : imageMeta.entrypoint;
    const description = this.flags.description ?? serviceName;
    const environment = await parseEnvironmentVariables(
      this.flags.env,
      this.flags["env-file"],
    );
    const ports = getPortMappings(
      imageMeta,
      this.flags["publish-all"],
      this.flags.publish,
    );
    const volumes = this.flags.volume;

    return {
      image,
      command,
      entrypoint,
      description,
      environment,
      ports,
      volumes,
    };
  }

  private async getImageAndMeta(projectId: string) {
    const { image } = this.args;
    const meta = await getImageMeta(this.apiClient, image, projectId);

    return { image, meta };
  }

  private getServiceName(): string {
    const { name } = this.flags;
    if (name !== undefined) {
      return name;
    }

    return dockerNames.getRandomName();
  }

  protected render({ service }: Result): ReactNode {
    if (this.flags.quiet) {
      return service.id;
    }

    return <ContainerUsageHints service={service} />;
  }
}

function matchServiceByName(name: string) {
  return (service: ContainerServiceResponse) => service.serviceName === name;
}
